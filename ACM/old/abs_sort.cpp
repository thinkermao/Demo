/* 
===========================================================================
A-解题报告

输入n(n<=100)个整数，按照绝对值从大到小排序后输出。
题目保证对于每一个测试实例，所有的数的绝对值都不相等。

简单的排序题目，最简单的办法就是冒泡排序。但是既然是练习，就练习一下快速排序。

快速排序原理：
	通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另
	外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，
	整个排序过程可以递归进行，以此达到整个数据变成有序序列。

那么如何将数据分成一边比另一边都要小的两部分呢？
	1、选取数组第一个数据作为关键数据；
	2、分别从后向前和从前向后扫描，比关键数据大的就交给对方；
	3、重复步骤二，直到两边相遇，扫描结束；
*/


#include <stdio.h>
#include <stdlib.h>

void QuickSort(int a[],int numsize)		/* a是整形数组，numsize是元素个数 */
{
	int i=0, j = numsize-1, val = a[0];	/* 指定参考值val大小 */
	if (numsize <= 1) return ;			/* 确保数组长度至少为2，否则无需排序 */
	while (i < j) { 					/* 循环结束条件 */
		/* 从后向前搜索比val小的元素，找到后填到a[i]中并跳出循环
		   注意if中的条件每次比较后j要向前移动一位（a[j--]）。当
		   条件成立时的j向前移动了一位，所以a[++j]。把数据交还给
		   前面以后，因为其一定比关键值小，所以i++指向下一位 */
		while (j > i)
			if (abs(a[j--]) < abs(val)) {
				a[i++]=a[++j];
				break;
			}
		/* 从前往后搜索比val大的元素，找到后填到a[j]中并跳出循环
		   具体细节参照上面注释 */
		while (j > i) 
			if (abs(a[i++]) > abs(val)) {
				a[j--] = a[--i];
				break;
			}
	}
	a[i] = val;							/* 将保存在val中的数放到a[i]中*/
	QuickSort(a, i);					/* 递归，对前i个数排序*/
	QuickSort(a+i+1, numsize-i-1);		/* 对i+2到numsize这numsize-1-i个数排序
										   此处的a+i+1表示&a[i+1] */
}

int main() {
	int n = 0, data[100];
	while (scanf("%d", &n) == 1 && n) {
		int i = 0;
		while (i < n) scanf("%d", &data[i++]);
			
		QuickSort(data, n);
		
		/* 排序结果是升序的，题目要求是降序输出，所以i = n-1, 注意最后一个数后面不要有空格 */
		i = n-1;
		while (i > 0) printf("%d ", data[i--]);
		printf("%d\n", data[0]);
	}
	return 0;
}
